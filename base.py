from flask import Flask , render_template , json, redirect, url_for, request, flash
from flask_wtf import FlaskForm
from datetime import datetime
from wtforms import BooleanField, PasswordField, StringField, SubmitField, ValidationError
from wtforms.validators import EqualTo, DataRequired, Email, Length
from wtforms.fields.html5 import DateField
from flask_login import UserMixin, login_user, LoginManager, login_required, logout_user, current_user
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from wtforms.widgets import TextArea

app = Flask(__name__ , template_folder="Templates")
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['SECRET_KEY'] = "please feed us Sarah Mangelsdorf"
db = SQLAlchemy(app)

loginManager = LoginManager()
loginManager.init_app(app)
loginManager.login_view = 'login'

@loginManager.user_loader
def load_user(user_id):
	return Users.query.get(int(user_id))

class Users(db.Model, UserMixin):
	#ID autogenerated upon user sign up
	id = db.Column(db.Integer, primary_key = True)
	username = db.Column(db.String(18), nullable = False, unique = True)
	name = db.Column(db.String(80), nullable = False)
	email = db.Column(db.String(80), nullable = False, unique = True)
	dateOfRegistration = db.Column(db.DateTime, default = datetime.utcnow)
	passwordHash = db.Column(db.String(128))

	@property
	def password(self):
		raise AttributeError('Attribute Error')

	@password.setter
	def password(self, password):
		self.passwordHash = generate_password_hash(password)

	def verify_password(self, password):
		return check_password_hash(self.passwordHash, password)

	#idk if I need this yet? but putting it here to not get errors possibly
	def __repr__(self):
		return '<Name %r>' % self.name

class SignUpForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	passwordHash = PasswordField("Password", validators=[DataRequired(), EqualTo('passwordHashConfirm')])
	passwordHashConfirm = PasswordField("Re-enter your Password", validators=[DataRequired()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	submit = SubmitField("Submit")

class LoginForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	password = PasswordField("Password", validators=[DataRequired()])
	submit = SubmitField("Log In")

class UpdateForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	passwordHash = PasswordField("Password", validators=[DataRequired(), EqualTo('passwordHashConfirm')])
	passwordHashConfirm = PasswordField("Re-enter your Password", validators=[DataRequired()])
	submit = SubmitField("Update")

class BlogPost(db.Model):
	id = db.Column(db.Integer, primary_key = True)
	postTitle = db.Column(db.String(300))
	article = db.Column(db.Text)
	name = db.Column(db.String(80))
	date = db.Column(db.DateTime, default = datetime.utcnow)

class BlogPostForm(FlaskForm):
	postTitle = StringField("Title", validators = [DataRequired()])
	name = StringField("Name", validators = [DataRequired()])
	article = StringField("Body", validators = [DataRequired()], widget = TextArea())
	submit = SubmitField("Publish Post")

@app.route('/signup', methods = ['GET', 'POST'])
def signup():
	name = None
	form = SignUpForm()
	if form.validate_on_submit():
		#checks to make sure the user's email is not in the database, should return None if the email is unique
		user = Users.query.filter_by(email = form.email.data).first()
		if user is None: 
			#line below is hashing the password with sha256 and returning the hash to the database
			hashedPassword = generate_password_hash(form.passwordHash.data, "sha256")
			user = Users(username = form.username.data, passwordHash = hashedPassword, name = form.name.data, email = form.email.data)
			db.session.add(user)
			db.session.commit()
		else:
			flash("There is already a user with this email. Try again.")
		name = form.name.data
		form.name.data = ''
		form.passwordHash.data = ''
		form.email.data = ''
		form.username.data = ''
		flash("Sign-Up Successful. Go to the Login In page to acces your account.")
	allUsers = Users.query.order_by(Users.dateOfRegistration)
	return render_template("signup.html", name = name, form = form, allUsers = allUsers)

@app.route('/login', methods = ['GET', 'POST'])
def login():

	form = LoginForm()

	if form.validate_on_submit():

		#returns the first result of a user with the email entered (should be only one instance though), if user doesn't exist then returns nothing'
		user = Users.query.filter_by(email = form.email.data).first()

		if user:
			if check_password_hash(user.passwordHash, form.password.data):
				login_user(user)
				return redirect(url_for('dashboard'))
			else:
				flash("Wrong Password")
		else:
			flash("Email not linked to an account")
	else:
		flash("Invalid information. Please try again.")
	return render_template("login.html", form = form)

@app.route('/redirecttest')
def redirecttest():
	return render_template("redirecttest.html")

@app.route('/dashboard', methods = ['GET', 'POST'])
@login_required
def dashboard():
	return render_template("dashboard.html")

@app.route('/updateinfo/<int:id>', methods = ['GET', 'POST'])
@login_required
def updateinfo(id):
	form = UpdateForm()
	user = Users.query.get_or_404(id)
	if form.validate_on_submit():
		user.name = request.form['name']
		user.email = request.form['email']
		user.username = request.form['username']
		user.passwordHash = generate_password_hash(request.form['passwordHash'], "sha256")
		db.session.commit()
		flash("User Updated Successfully")
		return render_template("updateinfo.html", form = form, user = user)
	else:
		flash("Invalid Form. Please Try Again.")
	return render_template("updateinfo.html", form = form, user = user)

@app.route('/publish', methods = ['GET', 'POST'])
@login_required
def publish():
	form = BlogPostForm()
	if form.validate_on_submit():
		blogPost = BlogPost(postTitle = form.postTitle.data, name = form.name.data, article = form.article.data)
		
		form.postTitle.data = ''
		form.name.data = ''
		form.article.data = ''

		db.session.add(blogPost)
		db.session.commit()
		flash("Your Post was Successfully Published")

	else:
		flash("Post not published, please try fill in all information.")

	return render_template("createpostform.html", form = form)

@app.route('/allposts')
def allposts():
	allPosts = BlogPost.query.order_by(BlogPost.date)

	return render_template("allposts.html", allPosts = allPosts)