from flask import Flask, render_template , json, redirect, url_for, request, flash, session
from flask_wtf import FlaskForm
from datetime import datetime
from wtforms import BooleanField, PasswordField, StringField, SubmitField, ValidationError
from wtforms.validators import EqualTo, DataRequired, Email, Length
from wtforms.fields.html5 import DateField
from flask_login import UserMixin, login_user, LoginManager, login_required, logout_user, current_user, logout_user
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from wtforms.widgets import TextArea
from flask_recaptcha import ReCaptcha
from itsdangerous import URLSafeTimedSerializer
import smtplib
import os

app = Flask(__name__ , template_folder="Templates")
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['SECRET_KEY'] = "please feed us Sarah Mangelsdorf"
app.config['RECAPTCHA_SITE_KEY'] = '6Le6an4dAAAAAGq2i0cGerF9vhPuH90KAUauDAc0'
app.config['RECAPTCHA_SECRET_KEY'] = '6Le6an4dAAAAAPshXg_PB29nH3EmWg3sYoGN-zrj'
recaptcha = ReCaptcha(app)
db = SQLAlchemy(app)

loginManager = LoginManager()
loginManager.init_app(app)
loginManager.login_view = 'login'

ts = URLSafeTimedSerializer(app.config["SECRET_KEY"])

@loginManager.user_loader
def load_user(user_id):
	return Users.query.get(int(user_id))

class Users(db.Model, UserMixin):
	#ID autogenerated upon user sign up
	id = db.Column(db.Integer, primary_key = True)
	username = db.Column(db.String(18), nullable = False, unique = True)
	name = db.Column(db.String(80), nullable = False)
	email = db.Column(db.String(80), nullable = False, unique = True)
	dateOfRegistration = db.Column(db.DateTime, default = datetime.utcnow)
	passwordHash = db.Column(db.String(128))
	articles = db.relationship('BlogPost', backref = 'author')

	@property
	def password(self):
		raise AttributeError('Attribute Error')

	@password.setter
	def password(self, password):
		self.passwordHash = generate_password_hash(password)

	def verify_password(self, password):
		return check_password_hash(self.passwordHash, password)

	def __repr__(self):
		return '<Name %r>' % self.name

class SignUpForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	passwordHash = PasswordField("Password", validators=[DataRequired(), EqualTo('passwordHashConfirm')])
	passwordHashConfirm = PasswordField("Re-enter your Password", validators=[DataRequired()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	submit = SubmitField("Submit")

class LoginForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	password = PasswordField("Password", validators=[DataRequired()])
	submit = SubmitField("Log In")

class UpdateForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	submit = SubmitField("Update")

class BlogPost(db.Model):
	id = db.Column(db.Integer, primary_key = True)
	postTitle = db.Column(db.String(300))
	article = db.Column(db.Text)
	name = db.Column(db.String(80))
	date = db.Column(db.DateTime, default = datetime.utcnow)
	userID = db.Column(db.Integer, db.ForeignKey('users.id'))

class BlogPostForm(FlaskForm):
	postTitle = StringField("Title", validators = [DataRequired()])
	name = StringField("Name", validators = [DataRequired()])
	article = StringField("Body", validators = [DataRequired()], widget = TextArea())
	submit = SubmitField("Publish Post")

class EmailList(db.Model):
	id = db.Column(db.Integer, primary_key = True)
	fname = db.Column(db.String(80))
	lname = db.Column(db.String(80))
	email = db.Column(db.String(80))

class EmailListForm(FlaskForm):
	fname = StringField("First Name", validators=[DataRequired()])
	lname = StringField("Last Name", validators=[DataRequired()])
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	submit = SubmitField("Subscribe")

class EmailForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	submit = SubmitField("Submit")

class PasswordResetForm(FlaskForm):
	passwordHash = PasswordField("New Password", validators=[DataRequired(), EqualTo('passwordHashConfirm')])
	passwordHashConfirm = PasswordField("Re-enter your New Password", validators=[DataRequired()])
	submit = SubmitField("Submit")



#here starts thee pages

@app.route('/signup', methods = ['GET', 'POST'])
def signup():
	
	if current_user.is_authenticated:
		return redirect(url_for('dashboard'))

	name = None
	form = SignUpForm()
	if form.validate_on_submit():
		if recaptcha.verify():
			#checks to make sure the user's email is not in the database, should return None if the email is unique
			user = Users.query.filter_by(email = form.email.data).first()
			if user is None: 
				#line below is hashing the password with sha256 and returning the hash to the database
				hashedPassword = generate_password_hash(form.passwordHash.data, "sha256")
				user = Users(username = form.username.data, passwordHash = hashedPassword, name = form.name.data, email = form.email.data)
				db.session.add(user)
				db.session.commit()
				flash("Sign-Up Successful. Go to the Login In page to acces your account.")
				return redirect(url_for('login'))
			else:
				flash("There is already a user with this email. Try again.")

			name = form.name.data
			form.name.data = ''
			form.passwordHash.data = ''
			form.email.data = ''
			form.username.data = ''
		else:
			flash("Please fill out the captcha and try again.")
			
	allUsers = Users.query.order_by(Users.dateOfRegistration)
	return render_template("signup.html", name = name, form = form, allUsers = allUsers)

@app.route('/login', methods = ['GET', 'POST'])
def login():
	form = LoginForm()
	if current_user.is_authenticated:
		return redirect(url_for('dashboard'))
	

	if form.validate_on_submit():

		#returns the first result of a user with the email entered (should be only one instance though), if user doesn't exist then returns nothing'
		user = Users.query.filter_by(email = form.email.data).first()

		if user:
			if check_password_hash(user.passwordHash, form.password.data):
				login_user(user)
				return redirect(url_for('dashboard'))
			else:
				flash("Wrong Password")
		else:
			flash("Email not linked to an account")
	else:
		flash("Invalid information. Please try again.")
	return render_template("login.html", form = form)

@app.route('/logout')
@login_required
def logout():
    logout_user()
    if session.get('was_once_logged_in'):
        del session['was_once_logged_in']
    flash('You have successfully logged yourself out.')
    return redirect(url_for('login'))


@app.route('/dashboard', methods = ['GET', 'POST'])
@login_required
def dashboard():
	return render_template("dashboard.html")

@app.route('/updateinfo/<int:id>', methods = ['GET', 'POST'])
@login_required
def updateinfo(id):
	form = UpdateForm()
	user = Users.query.get_or_404(id)
	if form.validate_on_submit():
		user.name = request.form['name']
		user.email = request.form['email']
		user.username = request.form['username']
		db.session.commit()
		flash("User Updated Successfully")
		return render_template("updateinfo.html", form = form, user = user)
	else:
		flash("Invalid Form. Please Try Again.")
	return render_template("updateinfo.html", form = form, user = user)

@app.route('/publish', methods = ['GET', 'POST'])
@login_required
def publish():
	form = BlogPostForm()
	if form.validate_on_submit():
		if recaptcha.verify():
			author = current_user.id
			blogPost = BlogPost(postTitle = form.postTitle.data, name = form.name.data, article = form.article.data, userID = author)
		
			form.postTitle.data = ''
			form.name.data = ''
			form.article.data = ''

			db.session.add(blogPost)
			db.session.commit()
			flash("Your Post was Successfully Published")
			return redirect(url_for('allposts'))

		else:
			flash("Please fill out the captcha.")

	else:
		flash("Post not published, please try fill in all information.")

	return render_template("createpostform.html", form = form)

@app.route('/allposts')
def allposts():
	allPosts = BlogPost.query.order_by(BlogPost.date)

	return render_template("allposts.html", allPosts = allPosts)

@app.route('/userpost/<int:id>')
def userpost(id):
	blogPost = BlogPost.query.get_or_404(id)
	return render_template('userpost.html', blogPost = blogPost)

@app.route('/userpost/edit/<int:id>', methods = ['GET', 'POST'])
@login_required
def edit(id):
	blogPost = BlogPost.query.get_or_404(id)
	form = BlogPostForm()


	if form.validate_on_submit():
		blogPost.postTitle = form.postTitle.data
		blogPost.name = form.name.data
		blogPost.article = form.article.data
		db.session.add(blogPost)
		db.session.commit()

		return redirect(url_for('userpost', id = blogPost.id))

	if current_user.id == blogPost.userID:

		form.postTitle.data = blogPost.postTitle
		form.name.data = blogPost.name
		form.article.data = blogPost.article

		return render_template("createpostform.html", form = form)

	else:
		
		flash("You cannot edit this post.")

		return redirect(url_for('allposts'))

@app.route('/userpost/delete/<int:id>')
@login_required
def delete(id):
	blogPost = BlogPost.query.get_or_404(id)

	userID = current_user.id

	if userID == blogPost.userID:

		db.session.delete(blogPost)
		db.session.commit()

		flash("Post Deleted")

		return redirect(url_for('allposts'))

	else:
		
		flash("Cannot delete other user's posts.")

	return redirect(url_for('allposts'))
	

@app.route('/aboutus')
def aboutus():
	return render_template('aboutus.html')

@app.route('/subscribe', methods = ['GET', 'POST'])
def subscribe():
	form = EmailListForm()
	if form.validate_on_submit():
		recipient = EmailList(fname = form.fname.data, lname = form.lname.data, email = form.email.data)

		form.fname.data = ''
		form.lname.data = ''
		form.email.data = ''

		db.session.add(recipient)
		db.session.commit()
		message = "You have successfully subscribed to the Scorpion email list."
		server = smtplib.SMTP("smtp.gmail.com", 587)
		server.starttls()
		server.login("scorpionblog.roc@gmail.com", os.getenv("EMAILPASS"))
		server.sendmail("scorpionblog.roc@gmail.com", recipient.email, message)

		flash("Successfully Subscribed to Email List")

	else:
		flash("Information Invalid")

	return render_template('subscribe.html', form = form)

@app.route('/reset', methods=["GET", "POST"])
def resetpassword():
	form = EmailForm()
	if form.validate_on_submit():
		user = Users.query.filter_by(email = form.email.data).first_or_404()

		token = ts.dumps(user.email, salt='recover-key')
		print(token)
		recoveryURL = url_for('tokenreset', token = token)

		message = recoveryURL
		server = smtplib.SMTP("smtp.gmail.com", 587)
		server.starttls()
		server.login("scorpionblog.roc@gmail.com", os.getenv("EMAILPASS"))
		server.sendmail("scorpionblog.roc@gmail.com", user.email, message)
		form.email = ''

		flash("Password Reset Link Sent")

		return redirect(url_for('login'))

	else: 

		flash("Please enter your email.")

	return render_template('reset.html', form = form)

@app.route('/tokenreset/<token>', methods=["GET", "POST"])
def tokenreset(token):
    try:
        email = ts.loads(token, salt="recover-key", max_age=86400)

    except:

        abort(404)

    form = PasswordResetForm()

    if form.validate_on_submit():
        user = Users.query.filter_by(email = email).first_or_404()

        hashedPassword = generate_password_hash(form.passwordHash.data, "sha256")
        user.passwordHash = hashedPassword

        db.session.add(user)
        db.session.commit()

        return redirect(url_for('login'))

    else: 
        flash("Passwords do not match, please try again.")

    return render_template('tokenreset.html', form=form, token=token)


#Error Handlers
@app.errorhandler(404)
def page_not_found(e):
    return render_template('error404.html'), 404

@app.errorhandler(500)
def page_not_found(e):
    return render_template('error500.html'), 500