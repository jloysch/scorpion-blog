
from flask import Flask , render_template , json, redirect, url_for, request, flash
from flask_wtf import FlaskForm
from datetime import datetime
from wtforms import BooleanField, PasswordField, StringField, SubmitField, ValidationError
from wtforms.validators import EqualTo, DataRequired, Email, Length
from wtforms.fields.html5 import DateField
from flask_login import UserMixin, login_user, LoginManager, login_required, logout_user, current_user
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from wtforms.widgets import TextArea

app = Flask(__name__ , template_folder="templates", static_folder='res')
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['SECRET_KEY'] = "please feed us Sarah Mangelsdorf"
db = SQLAlchemy(app)

loginManager = LoginManager()
loginManager.init_app(app)
loginManager.login_view = 'login'

@loginManager.user_loader
def load_user(user_id):
	return Users.query.get(int(user_id))

class Users(db.Model, UserMixin):
	#ID autogenerated upon user sign up
	id = db.Column(db.Integer, primary_key = True)
	username = db.Column(db.String(18), nullable = False, unique = True)
	name = db.Column(db.String(80), nullable = False)
	email = db.Column(db.String(80), nullable = False, unique = True)
	dateOfRegistration = db.Column(db.DateTime, default = datetime.utcnow)
	passwordHash = db.Column(db.String(128))

	@property
	def password(self):
		raise AttributeError('Attribute Error')

	@password.setter
	def password(self, password):
		self.passwordHash = generate_password_hash(password)

	def verify_password(self, password):
		return check_password_hash(self.passwordHash, password)

	def __repr__(self):
		return '<Name %r>' % self.name

class SignUpForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	passwordHash = PasswordField("Password", validators=[DataRequired(), EqualTo('passwordHashConfirm')])
	passwordHashConfirm = PasswordField("Re-enter your Password", validators=[DataRequired()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	submit = SubmitField("Submit")

class LoginForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	password = PasswordField("Password", validators=[DataRequired()])
	submit = SubmitField("Log In")

class UpdateForm(FlaskForm):
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	name = StringField("Name", validators=[DataRequired()])
	username = StringField("Username", validators=[DataRequired()])
	submit = SubmitField("Update")

class BlogPost(db.Model):
	id = db.Column(db.Integer, primary_key = True)
	postTitle = db.Column(db.String(300))
	article = db.Column(db.Text)
	name = db.Column(db.String(80))
	date = db.Column(db.DateTime, default = datetime.utcnow)

class BlogPostForm(FlaskForm):
	postTitle = StringField("Title", validators = [DataRequired()])
	name = StringField("Name", validators = [DataRequired()])
	article = StringField("Body", validators = [DataRequired()], widget = TextArea())
	submit = SubmitField("Publish Post")

class EmailList(db.Model):
	id = db.Column(db.Integer, primary_key = True)
	fname = db.Column(db.String(80))
	lname = db.Column(db.String(80))
	email = db.Column(db.String(80))

class EmailListForm(FlaskForm):
	fname = StringField("First Name", validators=[DataRequired()])
	lname = StringField("Last Name", validators=[DataRequired()])
	email = StringField("Email Address", validators=[DataRequired(), Email()])
	submit = SubmitField("Subscribe")
	


@app.route('/signup', methods = ['GET', 'POST'])
def signup():
	name = None
	form = SignUpForm()
	if form.validate_on_submit():
		#checks to make sure the user's email is not in the database, should return None if the email is unique
		user = Users.query.filter_by(email = form.email.data).first()
		if user is None: #if unique
			#line below is hashing the password with sha256 and returning the hash to the database
			hashedPassword = generate_password_hash(form.passwordHash.data, "sha256")
			user = Users(username = form.username.data, passwordHash = hashedPassword, name = form.name.data, email = form.email.data)
			db.session.add(user)
			db.session.commit()
			return redirect(url_for('login'))
		else:
			flash("There is already a user with this email. Try again.")
		name = form.name.data
		form.name.data = ''
		form.passwordHash.data = ''
		form.email.data = ''
		form.username.data = ''
		flash("Sign-Up Successful. Go to the Login In page to acces your account.")
	allUsers = Users.query.order_by(Users.dateOfRegistration)
	return render_template("signup.html", name = name, form = form, allUsers = allUsers)

@app.route('/login', methods = ['GET', 'POST'])
def login():

	form = LoginForm()

	if form.validate_on_submit():

		#returns the first result of a user with the email entered (should be only one instance though), if user doesn't exist then returns nothing'
		user = Users.query.filter_by(email = form.email.data).first()

		if user:
			if check_password_hash(user.passwordHash, form.password.data):
				login_user(user)
				return redirect(url_for('dashboard'))
			else:
				flash("Wrong Password")
		else:
			flash("Email not linked to an account")
	else:
		flash("Invalid information. Please try again.")
	return render_template("login.html", form = form)


@app.route('/dashboard', methods = ['GET', 'POST'])
@login_required
def dashboard():
	return render_template("dashboard.html")

@app.route('/updateinfo/<int:id>', methods = ['GET', 'POST'])
@login_required
def updateinfo(id):
	form = UpdateForm()
	user = Users.query.get_or_404(id)
	if form.validate_on_submit():
		user.name = request.form['name']
		user.email = request.form['email']
		user.username = request.form['username']
		db.session.commit()
		flash("User Updated Successfully")
		return render_template("updateinfo.html", form = form, user = user)
	else:
		flash("Invalid Form. Please Try Again.")
	return render_template("updateinfo.html", form = form, user = user)

@app.route('/publish', methods = ['GET', 'POST'])
@login_required
def publish():
	form = BlogPostForm()
	if form.validate_on_submit():
		blogPost = BlogPost(postTitle = form.postTitle.data, name = form.name.data, article = form.article.data)
		
		form.postTitle.data = ''
		form.name.data = ''
		form.article.data = ''

		db.session.add(blogPost)
		db.session.commit()
		flash("Your Post was Successfully Published")
		return redirect(url_for('allposts'))

	else:
		flash("Post not published, please try fill in all information.")

	return render_template("createpostform.html", form = form)

@app.route('/allposts')
def allposts():
	allPosts = BlogPost.query.order_by(BlogPost.date)

	return render_template("allposts.html", allPosts = allPosts)

@app.route('/userpost/<int:id>')
def userpost(id):
	blogPost = BlogPost.query.get_or_404(id)
	return render_template('userpost.html', blogPost = blogPost)

@app.route('/aboutus')
def aboutus():
	return render_template('aboutus.html')

@app.route('/subscribe', methods = ['GET', 'POST'])
def subscribe():
	form = EmailListForm()
	if form.validate_on_submit():
		recipient = EmailList(fname = form.fname.data, lname = form.lname.data, email = form.email.data)

		form.fname.data = ''
		form.lname.data = ''
		form.email.data = ''

		db.session.add(recipient)
		db.session.commit()
		flash("Successfully Subscribed to Email List")

	else:
		flash("Information Invalid")

	return render_template('subscribe.html', form = form)

@app.route('/', methods = ['GET', 'POST'])
def generateLandingPage():
    return render_template("home.html")
    
@app.route('/giles', methods = ['GET', 'POST'])
def generateStaticGiles():
    return render_template("giles.html")

@app.route('/loysch', methods = ['GET', 'POST'])
def generateStaticLoysch():
    return render_template("loysch.html")

@app.route('/emersyn', methods = ['GET', 'POST'])
def generateStaticEmersyn():
    return render_template("emersyn.html")
    
@app.route('/posts', methods = ['GET', 'POST'])
def generatePostsPage():
    return render_template("member.html")
    
@app.route('/store', methods = ['GET', 'POST'])
def generateStorePage():
    return render_template("store.html")
    
@app.route('/mycart', methods = ['GET', 'POST'])
def generateCartPage():
    return render_template("cart.html")


#Error Handlers
@app.errorhandler(404)
def page_not_found(e):
    return render_template('error404.html'), 404

@app.errorhandler(500)
def page_not_found(e):
    return render_template('error500.html'), 500